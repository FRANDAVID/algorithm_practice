1. 经典的动态规划理解
输入：
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
输出：
30

思路：
第一种：会采用回溯进行解决，记录每次然后相加得到结果 DP_1
第二种：采用备用数组，从下往上递推进行得到结果并且打印最优结构 DP_2
第三种：基于第一种的优化递 DP_3


2. 最长上升子序列

第一种：
01 背包
有n 种不同的物品，每个物品有两个属性，size 体积，value 价值，现在给一个容量为 w 的背包，问最多可带走多少价值的物品。
int f[w+1];   //f[x] 表示背包容量为x 时的最大价值
for (int i=0; i<n; i++)
    for (int j=w; j>=size[i]; j--)
        f[j] = max(f[j], f[j-size[i]]+value[i]);

完全背包
如果物品不计件数，就是每个物品不只一件的话，稍微改下即可
for (int i=0; i<n; i++)
    for (int j=size[i]; j<=w; j++)
        f[j] = max(f[j], f[j-size[i]]+value[i]);

f[w] 即为所求
    初始化分两种情况：
    1、如果背包要求正好装满则初始化 f[0] = 0, f[1~w] = -INF;
    2、如果不需要正好装满 f[0~v] = 0;




